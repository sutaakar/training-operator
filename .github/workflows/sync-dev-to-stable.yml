# This workflow automatically creates a temporary branch from dev to sync with stable branch, for image related changes creates a PR with "lake-gate" label for verification
# It runs every 4 hours and can be triggered manually
#
# This workflow uses the built-in GITHUB_TOKEN with the required permissions set below.

name: Sync Dev to Stable

on:
  schedule:
    # Run every 4 hours
    - cron: '0 */4 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

# Configuration: PR Reviewers
# To modify who gets requested to review sync PRs, update the list below with comma-separated or space-separated GitHub usernames
env:
  PR_REVIEWERS: "sutaakar"

jobs:
  lake-gate:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Configure Git
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

    - name: Check for differences between dev and stable
      id: check-diff
      run: |
        set -euo pipefail
        # Ensure we have the latest refs
        git fetch origin dev
        git fetch origin stable || {
          echo "Error: stable branch doesn't exist. Please create the stable branch first."
          exit 1
        }

        # Update local refs to match remote
        git checkout dev
        git reset --hard origin/dev
        git checkout -B stable origin/stable

        # Get commits that are in dev but not in stable
        NEW_COMMITS=$(git rev-list stable..dev --reverse)

        if [ -z "$NEW_COMMITS" ]; then
          echo "No new commits to cherry-pick"
          echo "new_commits=" >> $GITHUB_OUTPUT
        else
          echo "Found new commits to cherry-pick:"
          echo "$NEW_COMMITS"
          # Store commits as a single line with spaces
          COMMITS_LINE=$(echo "$NEW_COMMITS" | tr '\n' ' ' | sed 's/ $//')
          echo "new_commits=$COMMITS_LINE" >> $GITHUB_OUTPUT

          # Get the latest commit hash for PR title
          LATEST_COMMIT=$(echo "$NEW_COMMITS" | tail -n1)
          LATEST_COMMIT_SHORT=$(git rev-parse --short "$LATEST_COMMIT")
          LATEST_COMMIT_MSG=$(git log --format=%s -n 1 "$LATEST_COMMIT")
          echo "latest_commit=$LATEST_COMMIT" >> $GITHUB_OUTPUT
          echo "latest_commit_short=$LATEST_COMMIT_SHORT" >> $GITHUB_OUTPUT
          echo "latest_commit_msg=$LATEST_COMMIT_MSG" >> $GITHUB_OUTPUT
        fi

    - name: Check for existing sync PRs
      id: check-existing-pr
      if: steps.check-diff.outputs.new_commits != ''
      run: |
        set -euo pipefail
        # Look for existing PRs with the lake-gate label
        EXISTING_PR_DATA=$(gh pr list --base stable --label "lake-gate" --state open --json number,headRefName,title | jq -r '.[0] // empty')

        if [ -n "$EXISTING_PR_DATA" ] && [ "$EXISTING_PR_DATA" != "null" ]; then
          EXISTING_PR_NUMBER=$(echo "$EXISTING_PR_DATA" | jq -r '.number')
          EXISTING_PR_BRANCH=$(echo "$EXISTING_PR_DATA" | jq -r '.headRefName')
          echo "Found existing PR: #$EXISTING_PR_NUMBER (branch: $EXISTING_PR_BRANCH)"
          echo "existing_pr_number=$EXISTING_PR_NUMBER" >> $GITHUB_OUTPUT
          echo "existing_pr_branch=$EXISTING_PR_BRANCH" >> $GITHUB_OUTPUT

          # Check if the existing PR already contains the latest commit
          PR_TITLE=$(echo "$EXISTING_PR_DATA" | jq -r '.title')
          LATEST_COMMIT_SHORT="${{ steps.check-diff.outputs.latest_commit_short }}"

          if echo "$PR_TITLE" | grep -q "$LATEST_COMMIT_SHORT"; then
            echo "Existing PR already contains the latest commit"
            echo "pr_up_to_date=true" >> $GITHUB_OUTPUT
          else
            echo "Existing PR is outdated"
            echo "pr_up_to_date=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "No existing cherry-pick PR found"
          echo "existing_pr_number=" >> $GITHUB_OUTPUT
          echo "existing_pr_branch=" >> $GITHUB_OUTPUT
          echo "pr_up_to_date=false" >> $GITHUB_OUTPUT
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Close outdated PR and delete branch
      if: steps.check-diff.outputs.new_commits != '' && steps.check-existing-pr.outputs.existing_pr_number != '' && steps.check-existing-pr.outputs.pr_up_to_date == 'false'
      run: |
        set -euo pipefail
        PR_NUMBER="${{ steps.check-existing-pr.outputs.existing_pr_number }}"
        BRANCH_NAME="${{ steps.check-existing-pr.outputs.existing_pr_branch }}"

        # Safety check: Verify the branch matches automation pattern before closing/deleting
        if [[ "$BRANCH_NAME" =~ ^lake-gate- ]]; then
          echo "Branch matches automation pattern (lake-gate-*), proceeding with closure and deletion..."
          echo "Closing outdated PR #$PR_NUMBER (branch: $BRANCH_NAME)"
          gh pr close "$PR_NUMBER" --comment "Closing this PR as newer commits are available. A new PR will be created automatically."

          sleep 5  # Brief pause to ensure PR operations complete

          # Delete the temporary branch
          if [ -n "$BRANCH_NAME" ]; then
            echo "Deleting temporary branch: $BRANCH_NAME"
            git push origin --delete "$BRANCH_NAME" || {
              echo "Warning: Failed to delete branch $BRANCH_NAME (it may have already been deleted)"
            }
          else
            echo "Warning: No branch name found for PR #$PR_NUMBER"
          fi
        else
          echo "Warning: Branch '$BRANCH_NAME' does not match expected automation pattern (lake-gate-*). Skipping closure and deletion to prevent impacting user branches."
          echo "PR #$PR_NUMBER will remain open. Manual intervention may be required."
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Create sync branch and PR
      if: steps.check-diff.outputs.new_commits != '' && steps.check-existing-pr.outputs.pr_up_to_date == 'false'
      run: |
        set -euo pipefail
        # Create a unique branch name with timestamp
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        BRANCH_NAME="lake-gate-$TIMESTAMP"

        echo "Creating branch: $BRANCH_NAME from dev"
        git checkout dev
        git checkout -b "$BRANCH_NAME"

        # Push the branch
        git push origin "$BRANCH_NAME"

        # Prepare PR body
        COMMITS="${{ steps.check-diff.outputs.new_commits }}"
        LATEST_COMMIT="${{ steps.check-diff.outputs.latest_commit }}"
        LATEST_COMMIT_SHORT="${{ steps.check-diff.outputs.latest_commit_short }}"
        COMMIT_COUNT=$(echo "$COMMITS" | wc -w)

        # Build PR body using here document
        PR_BODY=$(cat << EOF
        ## Automated Sync from dev to stable

        This PR automatically syncs the \`dev\` branch to the \`stable\` branch by creating a temporary branch directly from dev.

        **Latest commit:** $LATEST_COMMIT_SHORT - ${{ steps.check-diff.outputs.latest_commit_msg }}
        **Total commits to sync:** $COMMIT_COUNT

        ## âš ï¸ IMPORTANT: How to Merge

        **ðŸš« DO NOT use the GitHub merge button!**

        Once all checks are complete, comment **\`/approve\`** on this PR to automatically fast-forward merge the stable branch to point to the same commit as this temporary branch.

        **Only use the \`/approve\` command - the GitHub merge button will not work correctly for this automated sync process.**

        ## Pre-merge Checklist

        Before approving this PR, please ensure the following tasks are completed:

        - [ ] **PR checks**: PR checks passed
        - [ ] **E2E tests**: Smoke and sanity tests passed against cluster with training operator image built from this PR
          - [ ] Build operator image locally (\`podman build -f build/images/training-operator/Dockerfile.rhoai .\`), upload it to quay
          - [ ] Adjust [params.env](https://github.com/opendatahub-io/training-operator/blob/$BRANCH_NAME/manifests/rhoai/params.env) file to reference uploaded image
          - [ ] Provision OCP cluster with latest ODH nightly
          - [ ] Install modified operator using [update-training.sh](https://github.com/opendatahub-io/training-operator/blob/$BRANCH_NAME/odh_utils/update-training.sh) (or manually)
          - [ ] Wait until training operator Pod is reprovisioned
          - [ ] Run smoke and sanity tests using Jenkins job or manually

        ### Commits to be synced:
        EOF
        )

        for commit in $COMMITS; do
          COMMIT_SHORT=$(git rev-parse --short "$commit")
          COMMIT_MSG=$(git log --format=%s -n 1 "$commit")
          PR_BODY="$PR_BODY"$'\n'"- $COMMIT_SHORT: $COMMIT_MSG"
        done

        PR_BODY="$PR_BODY"$'\n\n'"---"$'\n'"*This PR was created automatically by the sync workflow.*"

        # Create the PR
        PR_TITLE="Auto sync dev to stable (up to $LATEST_COMMIT_SHORT)"

        # Normalize PR_REVIEWERS by replacing commas with spaces and create reviewer flags
        REVIEWER_FLAGS=""
        NORMALIZED_REVIEWERS=$(echo "$PR_REVIEWERS" | tr ',' ' ')
        for reviewer in $NORMALIZED_REVIEWERS; do
          if [ -n "$reviewer" ]; then
            REVIEWER_FLAGS="$REVIEWER_FLAGS --reviewer $reviewer"
          fi
        done

        gh pr create \
          --title "$PR_TITLE" \
          --body "$PR_BODY" \
          --base stable \
          --head "$BRANCH_NAME" \
          --label "lake-gate" \
          $REVIEWER_FLAGS \
          --draft

        echo "Created PR: $PR_TITLE"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Summary
      run: |
        if [ -z "${{ steps.check-diff.outputs.new_commits }}" ]; then
          echo "âœ… No new commits to sync. Stable branch is up to date."
        elif [ "${{ steps.check-existing-pr.outputs.pr_up_to_date }}" == "true" ]; then
          echo "âœ… Existing PR already contains the latest commits. No action needed."
        else
          echo "âœ… Sync process completed. New PR created or existing PR updated."
        fi
